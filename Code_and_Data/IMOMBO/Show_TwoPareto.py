# #it[i][0], fit[i][1], fit[i][2] = decode(pop[i].TA, pop[i].AM, pop[i].WTS, pop[i].CTS)
# from os import WCONTINUED
# from urllib.request import FTPHandler
#
from localsearch import *
from popinit import indiv, initindiv3
from init import *
import random
from algorithmfunc import *
import matplotlib.pyplot as plt

# TA=[0, 0, 0, 0, 1, 0, 2, 3, 1, 1, 2, 3, 2, 3, 3, 4, 5, 1, 3, 5, 2, 0, 1, 5, 4, 1, 3, 4, 4, 5, 2, 2, 4, 5, 4, 5]
# AM=[1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0]
# WTS=[1, -1, 3, -1, 5, -1]
# CTS=[0, 2, 4]
# t=[0 for i in range(3)]
# t[0],t[1],t[2],finish_time = decode(TA, AM, WTS, CTS)
# print(t)


# t = [indiv() for _ in range(2)]
# popinitial(t,2)
#
# child1,child2 = cobotcross(t[0],t[1],3,20)

# curNAP = 5  # 假设curNAP的值为5
# objnum = 3  # 假设objnum的值为3
# domfit = [[0 for _ in range(objnum)] for _ in range(curNAP)]
#
# # 为了方便测试，我们给domfit赋值一些示例数据
# domfit = [
#     [3, 1, 4],
#     [1, 5, 9],
#     [2, 6, 5],
#     [3, 5, 8],
#     [4, 1, 2]
# ]
#
# # 计算每个目标的最小值
# min_values = [min(column) for column in zip(*domfit)]
#
# print("每个目标的最小值:", min_values)


#
# # for i in range(2):
# #     # mutated_choice = random.randint(0, 3)
# #     print(i)
#

# import numpy as np
# from IMOMBO import *
# from result_comp import *
# domfit = []
# domfit.append([[45.699999999999996, 1.6061127244245255, 25.659999999999997], [42.8, 2.8336679325518683, 2.1276], [30.6, 4.7291143512228855, 0], [43.5, 1.3930544224975203, 31.764900000000004], [34.8, 3.033597813770675, 19.3587], [65.99999999999999, 0.4913235648963832, 30.188100000000002], [48.7, 1.7508527561429976, 17.5063], [28.8, 4.6574797440817655, 16.4205], [27.7, 4.389068889222538, 20.0998], [41.8, 1.121502511990899, 35.6452], [47.800000000000004, 2.0863452680648797, 8.4834], [54.099999999999994, 0.9399247384096716, 35.4109], [52.6, 0.5906464225106085, 44.1655], [33.599999999999994, 3.8847052763048064, 14.594699999999998], [32.9, 3.7176261583204204, 15.695300000000001], [44.60000000000001, 2.260538576494507, 4.2315000000000005], [55.4, 0.9631354242908812, 27.459600000000002], [55.49999999999999, 0.5421100855117594, 36.582899999999995], [31.7, 4.244104292191624, 12.527700000000001], [30.6, 4.419791525227544, 6.1074], [55.3, 0.6072016299461438, 36.1717], [39.199999999999996, 2.3180566150219604, 29.004500000000007], [37.099999999999994, 3.3243994142909585, 9.5354], [50.1, 1.35729962572357, 23.527500000000003], [44.0, 2.142994152159351, 7.3806], [42.5, 1.8822734230710831, 11.475000000000001], [38.6, 2.750728733621719, 10.808000000000002], [39.3, 2.5290941914853073, 14.059499999999998], [51.69999999999999, 1.1654953215499964, 26.278499999999998], [49.6, 1.5690498493454221, 18.738100000000003], [39.800000000000004, 1.8312766828708575, 24.162000000000003], [30.499999999999996, 4.450111000390489, 5.1072], [41.1, 1.36471910392159, 34.3842], [37.5, 3.417724291301766, 9.289800000000001], [27.799999999999997, 4.521660767753746, 17.395699999999998], [33.6, 3.72159415283595, 0], [54.99999999999999, 1.1101584942743967, 28.051499999999997], [34.5, 2.9078390535666507, 21.3897], [43.9, 2.4746139957705604, 4.0527], [42.99999999999999, 2.0096439452366424, 21.1024], [51.099999999999994, 1.2022385300243208, 22.1956], [64.6, 1.43822990548066, 10.929599999999999], [31.7, 4.326000275385331, 0], [47.89999999999999, 1.0536754821528926, 32.887699999999995], [52.60000000000001, 1.5272182247974517, 8.588700000000001], [54.99999999999999, 1.0243365086142906, 29.350199999999997], [42.89999999999999, 2.647841948448109, 5.2164], [50.50000000000001, 1.6839134557141064, 8.8228], [37.8, 3.4569586887137578, 3.8151], [35.8, 3.605631790298817, 11.0487], [36.4, 3.2268198487406448, 9.8464], [46.4, 2.3540686984784993, 0], [40.6, 3.0572797741337365, 3.915], [39.79999999999999, 3.287715111023991, 2.6784], [46.599999999999994, 1.4732994543220408, 21.929199999999998], [38.3, 3.1249039498096267, 6.4077], [45.6, 2.5622145426496905, 0], [41.49999999999999, 2.992727668356488, 0], [35.6, 3.670380882868013, 9.2459], [44.1, 1.7435223477570547, 26.381700000000006]]
# )
# domfit.append([[12.8,2.5018,9.1951],[13.6,2.9377,3.2647],[29.1,0.7748,14.2449],[18.7,2.2621,4.7449],[16.4,1.9579,6.7058],[14.0,2.8366,4.1807]])
# plot_pareto_front1(domfit, 'pareto_frontier')
# #

# def select_top_crowded_solutions(npop, objnum, top_k=10):
#     fit = [p.fitness for p in npop]
#     crowding_distances = crowd(fit, len(npop), objnum)
#
#     # 将npop中的解和对应的拥挤度距离组成元组
#     solutions_with_distances = list(zip(npop, crowding_distances))
#     # 根据拥挤度距离对元组进行降序排序
#     sorted_solutions = sorted(solutions_with_distances, key=lambda x: x[1], reverse=True)
#     # 选择拥挤度距离前10的解
#     top_solutions = [solution for solution, _ in sorted_solutions[:top_k]]
#     return top_solutions
#
# pop, hyper, space= maincode2()
# top_solutions = select_top_crowded_solutions(pop,3)
# print(top_solutions)

# test = indiv()
# test.TA = [0, 2, 1, 1, 2, 3, 1, 3, 3, 0, 2, 2, 3, 3, 1, 2, 3, 3, 3, 3, 2, 2, 3, 3]
# test.AM = [2, 2, 2, 2, 2, 0, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 0, 2, 2]
# test.WTS = [1, 2, 0, 3]
# test.CTS = [2, 1, 3, 0]
#
# test1=indiv()
# test1.TA =[0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 3, 1, 3]
# test1.AM =[2, 2, 2, 2, 2, 1, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 0, 2, 2]
# test1.WTS = [1, -1, 3, 0]
# test1.CTS = [3, 1, -1, 0]
#
# child1, child2 = TAcross(test,test1,1,100)
#
# child1.fitness[0], child1.fitness[1], child1.fitness[2],child1.FT= decode(child1.TA, child1.AM, child1.WTS, child1.CTS)
# child2.fitness[0], child2.fitness[1], child2.fitness[2],child2.FT= decode(child2.TA, child2.AM, child2.WTS, child2.CTS)
# print('交叉后结果:')
# print('TA:',child1.TA)
# print('AM:',child1.AM)
# print('WTS:',child1.WTS)
# print('CTS:',child1.CTS)
# print('Fitness:',child1.fitness)
#
# # wcadjust(test.TA, test.AM, test.WTS, test.CTS)
# # print('调整后结果：')
# print('TA:',child2.TA)
# print('AM:',child2.AM)
# print('WTS:',child2.WTS)
# print('CTS:',child2.CTS)
# print('Fitness:',child2.fitness)


# =====================
# 数据准备（直接来自表格）
# =====================
data = {
    "Human Only": {
        "Cycle Time": [
29.8,
30.8,
31.2,
31.8,
32.7,
33.0,
35.0,
36.7,
37.4,
39.1,
39.8,
40.5,
41.3,
45.6,
47.8,
        ],
        "Ergonomic Risk":[
4.9175,
4.5176,
4.4718,
4.2773,
4.1530,
3.7445,
3.6059,
3.4685,
3.0916,
3.0557,
2.8689,
2.8363,
2.6130,
2.3513,
2.0632
        ]
    },
    "Human-robot without collaboration": {
        "Cycle Time":
            [
33.9,
34.0,
36.5,
37.3,
38.0,
39.5,
39.8,
41.4,
42.0,
42.9,
44.0,
45.8,
46.2,
48.1,
49.0
],
        "Ergonomic Risk": [
3.2275,
3.0659,
2.9904,
2.2010,
1.9556,
1.8155,
1.5806,
1.5274,
1.4596,
1.3247,
1.2103,
1.1453,
0.9840,
0.9726,
0.9550
]
    },
    "Human-robot with collaboration": {
        "Cycle Time": [
29.9,
30.4,
31.2,
32.1,
33.5,
34.2,
34.8,
36.0,
37.9,
38.9,
42.0,
43.1,
45.7,
47.4,
48.9
],
        "Ergonomic Risk": [
4.3922,
3.9355,
3.5938,
3.5651,
2.7314,
2.6767,
2.3067,
1.9632,
1.4900,
1.3058,
1.3019,
1.2671,
0.9566,
0.8025,
0.7679
]
    }
}


# =====================
# Pareto前沿计算函数
# =====================
def compute_pareto(points):
    """输入格式：[(x1,y1), (x2,y2)...]"""
    sorted_points = sorted(points, key=lambda x: (x[0], x[1]))
    pareto = [sorted_points[0]]

    for point in sorted_points[1:]:
        if point[1] < pareto[-1][1]:
            pareto.append(point)
    return np.array(pareto)


# =====================
# 计算各模式Pareto前沿
# =====================
pareto_sets = {}
for mode in data:
    points = list(zip(data[mode]["Cycle Time"], data[mode]["Ergonomic Risk"]))
    pareto_sorted = sorted(compute_pareto(points), key=lambda x: x[0])  # 按x升序排列
    pareto_sets[mode] = np.array(pareto_sorted)

# =====================
# 学术图表设置
# =====================
plt.rcParams.update({
    'font.family': 'Times New Roman',
    'font.size': 12,
    'axes.labelsize': 14,
    'axes.titlesize': 16,
    'figure.dpi': 300,
    'figure.figsize': (8, 6)
})

fig, ax = plt.subplots()

# =====================
# 颜色与标记定义
# =====================
# style_config = {
#     "Human Only": {"color": "#d86955", "marker": "o", "linestyle": ""},
#     "Human-robot without collaboration": {"color": "#7ac1d6", "marker": "s", "linestyle": ""},
#     "Human-robot with collaboration": {"color": "#65b2a3", "marker": "^", "linestyle": ""}
# }

style_config = {
    "Human Only": {"color": "#e75d49", "marker": "o", "linestyle": ""},
    "Human-robot without collaboration": {"color": "#ef934d", "marker": "s", "linestyle": ""},
    "Human-robot with collaboration": {"color": "#6592c0", "marker": "^", "linestyle": ""}
}

# =====================
# 绘制图形
# =====================
for mode in pareto_sets:
    # 绘制所有数据点
    ax.scatter(
        data[mode]["Cycle Time"],
        data[mode]["Ergonomic Risk"],
        color=style_config[mode]["color"],
        alpha=0.3,
        s=50,
        label=f'_nolegend_'  # 隐藏图例
    )

    # 绘制Pareto前沿
    x = pareto_sets[mode][:, 0]
    y = pareto_sets[mode][:, 1]
    ax.plot(
        x, y,
        color=style_config[mode]["color"],
        linestyle=style_config[mode]["linestyle"],
        linewidth=1.5,
        marker=style_config[mode]["marker"],
        markersize=8,
        markerfacecolor='white',
        markeredgecolor=style_config[mode]["color"],
        markeredgewidth=1.5,
        label=mode
    )

# =====================
# 图表标注
# =====================
ax.set_xlabel("Cycle Time", fontweight='bold')
ax.set_ylabel("Ergonomic Risk", fontweight='bold')
# ax.set_title("Pareto Frontiers of Assembly Modes", pad=20, fontweight='bold')

ax.grid(True, linestyle='--', alpha=0.7)
ax.legend(loc='upper right', frameon=True, framealpha=0.9)

# 优化坐标轴范围
ax.set_xlim(28, 52)
ax.set_ylim(0.5, 5.0)

# =====================
# 输出图像
# =====================
plt.tight_layout()
plt.savefig('pareto_frontiers(1).png', bbox_inches='tight')
plt.show()


# TA = [0, 0, 1, 1, 2, 1, 1, 3, 1, 3, 2, 2, 1, 3, 3, 2, 2, 1, 3, 3, 2, 3, 3, 2]
# finish_time = [1.8, 3.7, 1.2, 5.1, 2.4, 6.3999999999999995, 2.9, 4.999999999999999, 7.3999999999999995, 3.8, 3.9, 5.9, 10.899999999999999, 6.999999999999999, 1.7, 5.2, 9.4, 11.799999999999999, 8.399999999999999, 4.3999999999999995, 10.6, 10.499999999999998, 13.599999999999998, 7.0]
#
# # 确定工作站的数量
# num_stations = max(TA) + 1
#
# # 初始化 completion_times 向量
# completion_times = [[] for _ in range(num_stations)]
#
# # 遍历每个任务，根据 TA 向量将任务的完成时间添加到对应的工作站列表中
# for i in range(len(TA)):
#     station = TA[i]
#     time = finish_time[i]
#     completion_times[station].append(time)
#
# print("completion_times:", completion_times)

# TA=[0, 1, 0, 0, 1, 0, 3, 1, 3, 3, 3, 3]
# AM=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
# WTS=[1, 0, 3, 2]
# CTS=[-1, -1, -1, -1]
# cmax,TCE,F3,FT=decode(TA,AM,WTS,CTS)
#
# pre_indices=[0,3,5,2]
# for i in pre_indices:
#     print(i)
from init import *

#P16ER
# TA=[1,0,2,0,1,2,1,2,1,1,3,2,1,2,3,3]
# AM=[2,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1]
# WTS=[-1,-1,1,-1]
# CTS=[2,0,1,3]
# [15.0,0.5224,12.747]

#P16CT
# TA=[0,1,0,0,1,0,1,2,3,3,2,2,3,2,3,2]
# AM=[2,2,2,2,2,0,0,2,2,0,2,2,2,2,2,2]
# WTS=[0,3,2,1]
# CTS=[2,1,0,3]


#P12CT
# TA=[0,1,0,2,1,0,3,3,2,2,3,3]
# AM=[2,2,2,2,2,0,2,2,0,0,2,2]
# WTS=[1,2,0,3]
# CTS=[0,1,3,2]

# cmax, F3, TCE, ctask = decode(TA, AM, WTS, CTS)
# print("cmax:", cmax)
# print("F3:", F3)
# print("TCE:", TCE)
# print("ctask:", ctask)

#【4，9，10】
#【7，8，11，12】
# v1=[3,8,9,-1, -1, -1, -1, -1, -1, -1, -1, -1]
# n1=3
# v2=[6, 7, 10, 11, -1, -1, -1, -1, -1, -1, -1, -1]
# n2=4
# AM=[2,2,2,2,2,0,2,2,0,0,2,2]
# WTS=[1,2,0,3]
# CTS=[0,1,3,2]
# orderstation=3
# truesort(v1, v2, n1, n2, AM, WTS, CTS, orderstation)





# fit = [[28.899999999999995, 3.0976516192000862, 28.006999999999998], [49.00000000000001, 0.44170696195338643, 48.73460000000001], [39.50000000000001, 3.06193076117494, 0], [46.3, 0.6626800921034208, 44.1437], [38.50000000000001, 1.37499736930488, 35.5097], [36.1, 3.484945284464612, 4.2552], [35.699999999999996, 2.875096443336875, 12.250499999999999], [43.099999999999994, 2.041613534514968, 15.6075], [53.4, 0.8182818598617212, 29.5167], [39.3, 3.362713859206647, 1.4415], [33.1, 2.27349777610494, 31.673], [30.7, 2.584896795024803, 31.549400000000002], [41.5, 2.348514423215595, 7.0497000000000005], [39.8, 1.8694115619167866, 24.075100000000003], [46.39999999999999, 1.552476548829697, 18.606399999999997], [44.400000000000006, 0.8907146879293427, 40.3872], [48.400000000000006, 1.0453520492534274, 26.419400000000003], [37.4, 2.176464845229151, 23.631500000000006], [44.99999999999999, 1.6932669667636828, 17.8542], [49.800000000000004, 0.9585753254255687, 26.892600000000005]]
# domfit=[]
# domfit.append([[39.099999999999994, 3.0432145727320083, 0], [34.400000000000006, 2.9321048147685436, 19.5818], [37.3, 3.432086611179427, 0], [46.79999999999999, 2.1931003738382215, 0], [41.3, 2.4936035896020963, 7.4723999999999995], [66.2, 0.20169135346368547, 49.9792], [27.599999999999998, 3.137293488216046, 28.9191], [40.50000000000001, 1.6720670588257631, 28.6326], [52.79999999999998, 1.1377714942736665, 32.619899999999994], [74.39999999999999, 0.3576266186690077, 40.1124], [61.799999999999976, 0.7530916527084981, 36.9372], [105.5, 0.01862922274161521, 47.08250000000001], [88.49999999999999, 0.055251060559592426, 58.3809], [79.7, 1.1096085891638672, 10.561699999999998], [95.10000000000001, 0.031705504909624725, 46.56210000000001], [76.10000000000001, 0.6115697831670852, 23.6263], [83.19999999999999, 0.09351156324350096, 55.04900000000001], [84.49999999999999, 0.9415085609566971, 17.200400000000002], [54.09999999999998, 1.2821303860469584, 30.226399999999998], [72.69999999999999, 0.6320041004150972, 27.081199999999995]]
#               )
# domfit.append([[38.199999999999996, 2.940228388068695, 8.214999999999998], [30.9, 2.740722923010254, 28.172400000000003], [41.4, 1.790137164117594, 23.964299999999998], [31.9, 2.4090035658007873, 32.218700000000005], [29.9, 2.809580301634888, 30.293799999999997], [33.9, 2.1314920421700094, 31.7577], [37.7, 2.7196496728656525, 13.145000000000001], [36.0, 3.6090928246266034, 0], [45.8, 1.1052956468807689, 33.44949999999999], [35.0, 2.653344871133113, 23.433799999999998], [39.4, 3.098825574727342, 0], [42.99999999999999, 1.1756602430871874, 34.2713], [43.800000000000004, 1.4073034771340591, 25.656599999999997], [49.0, 0.910961700839602, 34.14920000000001], [49.0, 0.910961700839602, 34.14920000000001], [39.8, 1.8182228395299853, 26.2844], [45.1, 1.5082631450209742, 22.1396], [42.199999999999996, 1.7061415571270382, 22.055000000000003], [34.3, 2.097751056589764, 29.688200000000002], [36.9, 2.3096367274246887, 18.7443]]
#               )
# domfit.append([[64.00000000000001, 0.19039121832914535, 49.8356], [39.5, 2.960861355111008, 0], [61.699999999999996, 0.21627933129629454, 50.21410000000001], [64.00000000000001, 0.19039121832914535, 49.8356], [34.1, 3.2491876509886812, 13.791100000000002], [27.599999999999998, 3.0353191099465593, 28.5159], [47.1, 0.8933249366203969, 38.223600000000005], [58.70000000000001, 0.45884904979493873, 41.299], [43.2, 1.6733246517766083, 23.4972], [41.4, 2.367923806858909, 10.1439], [52.300000000000004, 1.1588273722206752, 21.942800000000005], [35.89999999999999, 2.7288602728838054, 17.5837], [46.3, 0.5827033829764339, 46.05350000000001], [36.5, 1.99085680261038, 27.514300000000002], [56.7, 0.6384582171114299, 33.4809], [52.9, 0.32574878117216394, 48.548899999999996], [29.299999999999997, 2.8663422682961133, 29.6455], [42.5, 2.240530366936064, 11.625900000000001], [42.900000000000006, 1.3734046941047637, 29.767200000000003], [57.100000000000016, 0.6801884329066663, 31.745300000000004]]
#               )
#
# lables =['MOABC','MOMBO','NSGA-II']
# for i in range(len(fit)):
#     for t in range(len(domfit[0])):
#         if dominates(fit[i],domfit[0][t]):
#             print(f'{fit[i]} dominated {lables[0]}: {domfit[0][t]}')
#
# for i in range(len(fit)):
#     for t in range(len(domfit[1])):
#         if dominates(fit[i],domfit[1][t]):
#             print(f'{fit[i]} dominated {lables[1]}: {domfit[1][t]}')
#
# for i in range(len(fit)):
#     for t in range(len(domfit[2])):
#         if dominates(fit[i],domfit[2][t]):
#             print(f'{fit[i]} dominated {lables[2]}: {domfit[2][t]}')